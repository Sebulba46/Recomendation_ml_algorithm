# Recomendation_ml_algorithm
This is my coursework to show off ability to create ml clustering system



**МИНИСТЕРСТВО ТРАНСПОРТА РОССИЙСКОЙ ФЕДЕРАЦИИ**

**ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ**

**УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ**

**«РОССИЙСКИЙ УНИВЕРСИТЕТ ТРАНСПОРТА»**

**(РУТ (МИИТ)**

Институт/факультет «Академия “Высшая Инженерная Школа”, АВИШ»

Специальность/Направление подготовки Информатика и вычислительная техника

**КУРСОВАЯ   РАБОТА**

**по дисциплине:** Технологии хранения больших данных


|**на тему:**|<p>Использование технологий хранения и обработки больших данных в рекомендательной маркетинговой системе сервиса food.com.</p><p></p>|
| - | :- |


|**Студент группы ШАД 211**|**(Шобанов Е. А.)**|
| - | - |
|**Научный руководитель**|**(Зуев И.А.)**|


**Москва 2022 г.**

24
# **Оглавление**
[**Оглавление	1****](#_Toc123553075)***

[**Основные термины	2****](#_Toc123553076)

[**Введение	4****](#_Toc123553077)

[**Основная часть	5****](#_Toc123553078)

[**Загрузка датасетов в базу данных	6****](#_Toc123553079)

[**Исследование датасета	7****](#_Toc123553080)

[**Наполнение карточек пользователей	9****](#_Toc123553081)

[**Исследование промежуточных результатов	13****](#_Toc123553082)

[**Предобработка и кластеризация	16****](#_Toc123553083)

[**Выводы по работе	17****](#_Toc123553084)

[**Заключение	21****](#_Toc123553085)

[**Список использованной литературы и программ	23****](#_Toc123553086)

[**Приложения	25****](#_Toc123553087)




# **Основные термины** 
Машинное обучение — крупный подраздел искусственного интеллекта, изучающий методы построения моделей, способных обучаться, и алгоритмов для их построения

Кластеризация (или кластерный анализ) — это задача разбиения множества объектов на группы, называемые кластерами. Внутри каждой группы должны оказаться «похожие» объекты, а объекты разных группы должны быть как можно более отличны.

Датасет — набор данных, используемый для анализа и машинного обучения.

Пайплайн – объединение многих процессов библиотеки sklearn в один процесс.

Фича – столбец датасета.

Карточка пользователя — строка в датасете пользователей, содержащая признаки, характеризующие конкретного пользователя.

Предобработка данных – процесс предварительной обработки данных, который позволяет модели лучше работать с ними.

Feature engineering — процесс предварительной обработки данных машинного обучения, извлекающий фичи(признаки) из необработанных данных. Предусматривает превращение данных, специфических для предметной области, в понятные для модели векторы. 

Data-engineering — совокупность практик и средств обработки данных для решения задач машинного обучения.


# **Введение**
Не секрет, что существует огромное количество бизнесов, работающих с клиентами. Многие успешные компании стараются разделить своих клиентов на группы, чтобы понимать как с ними эффективнее работать. Но успешный бизнес всегда растёт, следовательно клиентов становится всё больше и больше и разделять их становится всё дороже и дороже, нужно нанимать новых сотрудников, новых экспертов, чтобы данный процесс приводил к ожидаемым результатам.  Кластеризация — это задача разбиения множества объектов на группы, называемые кластерами. В данном случае множества клиентов, зачем нанимать сотрудников для сортировки клиентов по группам, если можно использовать данный математический алгоритм и, проанализировав признаки, которыми обладают клиенты, разделить их на кластеры. Итак, цель исследования – получить кластеры, в которые входят достаточно схожие пользователи, но имеющие небольшие отличия, таким образом рекомендации будут полезными.


# **Основная часть**
Использование больших данных – это важный процесс ведения бизнеса.  Благодаря данным можно проанализировать процессы, которые происходят в бизнесе, а после проделать модернизацию процессов в связи с сделанными после анализа выводами. В распоряжении исследования данные сервиса Food.com о их пользователях и их взаимодействии с рецептами в рамках сервиса. Задачей будет: проанализировать пользователей, выделить наиболее характеризующую их информацию из столбцов датасета и преобразовать её в карточки пользователей, и в конечном итоге, используя методы кластеризации, разделить пользователей на группы, чтобы в дальнейшем рекомендовать похожим пользователям похожие рецепты, тем самым простимулировать интерес к сервису. Другими словами — человек будет чаще заходить на портал, чтобы проверить не появилась ли какая-нибудь новая рекомендация. Результатом исследования будет алгоритм разделения пользователей на группы, а также анализ этих групп для более детального ознакомления с результатом.


## **Загрузка датасетов в базу данных**

В открытом доступе имеется несколько датасетов, которые можно увидеть на изображении выше, мною были выбраны два файла: «RAW\_recipes.csv» и «PP\_users.csv». Именно эти файлы представляют ценность для кластеризации, так как в датасете по рецептам содержится вся полезная информация о рецептах, с помощью которой будет составлена характеристика пользователей из второго датасета, где у каждого пользователя появится набор наиболее значимых для него признаков. Далее эти файлы были загружены в базу данных «Microsoft SQL Server Express», выбор был сделан в сторону неё, потому что это база данных, потому что данная база используется в личных целях для решения подобных задач. Сервер доступен из любой точки с доступом в интернет. И в целом загружать эти таблицы в базу данных нужно для удобства добавления информации о клиенте в строку в таблице о клиентах, так как мы легко можем сделать SQL запрос в lambda функции, применяемой к таблице.
## **Исследование датасета**
Исследование в первую очередь включает ознакомление с датасетом, далее происходит оценка текущих параметров, то есть столбцов, нужны они в дальнейшем или нет и каким будет применение, что мы можем добавить.  Для начала рассматриваются колонки датасета пользователей:

Что сразу можем приметить - к сожалению поле «techniques» не объяснено от слова совсем и не до конца понятно, каким образом интерпретировать техники готовки рецепта, они нигде в другом файле не описаны.

Так как мы делаем кластеризацию, необходимо добавить как можно больше информации о пользователе исходя из предоставленных данных. 

И сразу видно, что пользователей можно разбить на активных, средне активных и мало активных. Данное разделение будет осуществляться посредством квантильного деления распределения полей: «n\_items» и «n\_ratings».  

Также можно дать пользователю характеристику по оценкам, которые он ставит. Допустим: привередливый, объективный и не разбирающийся.

По таблице пользователей пока всё. Теперь начинается исследование таблицы рецептов: «recipes». С помощью неё можно добавить ещё больше информации в карточки пользователей.  

В данном датасете интересно время готовки. То есть можно найти медиану времени готовки всех рецептов, с которыми взаимодействовал пользователь. То есть понять какая продолжительность готовки ему больше всего подходит. 

Также можно найти самый встречающийся «Таг» в рецептах пользователя, то есть найти моду «Тагов».

И, в завершение, можно найти медиану количества шагов приготовления для пользователя, чтобы были группы людей, которые любят сложные рецепты и которые любят простые.

## **Наполнение карточек пользователей**
Для начала нужно перевести данные немного в другой формат, для этого создаётся таблица «interactions» с полями: «user\_id», «recipe\_id».



В ней будет храниться информация о том, какой пользователь с каким рецептом взаимодействовал, в оригинальных таблицах они хранятся в виде строковых значений, это неудобно.

Начинается добавление нужных столбцов 

Добавление групп активностей пользователей:

- Not active – не активный
- Slightly active – немного активный
- Active – активный
- Key-users – ключевые пользователи, генераторы контента

Они считаются по квантилям распределения.

Следующим этапом является добавление группы оценок.

Это просто самая частая оценка, которую ставил пользователь.

Далее добавляется медианное время приготовления рецептов для каждого пользователя. Которое достаётся по sql запросу к базе, а далее проводится агрегация в пандасе.

После добавляется самый встречающийся таг среди блюд, с которыми взаимодействовал пользователь, абсолютно таким же способом

За исключением того, что потребовалась кастомная агрегационная функция. 

Ну и в конце добавляется медианное количество шагов в рецептах каждому пользователю.




## **Исследование промежуточных результатов**
Итак, сейчас нужно проанализировать то, что было добавилено. Но для начала нужно проанализировать распределение по активностям пользователей: 

Как видно на графике, ситуация вполне логичная, чем активнее пользователь, тем меньше таких же активных пользователей.

Были добавлены группы по моде поставленных оценок, график распределения выглядит так: 

Больше всего человек, которые чаще всего ставят 5 за рецепт блюда, такая статистика вполне реальна. Также видим около 2500 людей, которые в основном ставят 4, в конце проверим куда попадут люди с самой частой оценкой 4.

Медианное время готовки получилось хорошее для кластеризации.

Вероятно, по кластерам это время особо не будет отличаться, а люди с большим медианным временем уйдут в кластеры выбросы, где будут 1 – 2 человека.

Также и медианное количество шагов. 

На графике выше отчётливо видно разделение по какому-то признаку, если он у нас присутствует, то в модели кластеризации это будет учтено.
## **Предобработка и кластеризация**
Итак, теперь создаётся пайплайн с предобработкой данных и уменьшением размерности числовых признаков.

Здесь, в первую очередь, добавляются полиномиальные фичи, данная операция позволяет интерпретировать данные по-разному, взять логарифм или возвести в степень. Далее применяется уменьшение размерности и создаётся три главных компоненты, если задаться желанием посмотреть какие вектора получились у этого метода, то можно их вывести на график точек двух столбцов. И потом производится нормализация данных. Категориальные же признаки кодируются с помощью «OneHotEncoder». 

После всего составляется конечный пайплайн с препроцессорном и алгоритмом кластеризации DBSCAN. Этот алгоритм был выбран не случайно, наша задача заключается в том, чтобы получить похожих людей по многим признакам, а DBSCAN работает за счёт нахождения небольших окружностей определённого радиуса и с определённым числом точек внутри. Это подходит под фактуру наших данных.
# **Выводы по работе**
Итак, кластеризация прошла успешно, проанализируем разделение на кластеры и сами кластеры.

Здесь были выделены только самые наполненные кластеры, выбросы в анализ не будут включены, кластеры с одним или двумя людьми не будут иметь высокой ценности для исследования.

Например, график ниже – это график рассеяния, он показывает «median\_cooking\_time» по x и «median\_cooking\_steps»

Данные хорошо разделены, видно кучку синих классов и основную область с полосками фиолетовых классов. Плюс, на этих графиках данные без нормализации, поэтому где-то классы могут быть разбросаны.

Или же другой график, здесь по x «n\_ratings» и «median\_cooking\_time»:

Видим, что близкие точки находятся в одном кластере, а расположение кластеров в данном случае, может быть, за счёт других признаков.

Ну последний график, на котором по x «median\_cooking\_time» и по y «rating\_type»:

Видим хорошее разделение именно по этому признаку, однако есть точки, которые были далеко от сложившихся кластеров.

Немало важным осталось проанализировать статистические показатели самих кластеров, естественно самых наполненных

- Кластер 0 имеет такие показатели:

- Кластер 1 имеет такие показатели:

- Кластер 2 имеет такие показатели:

- Кластер 4 имеет такие показатели:

Основные отличия видим по количеству поставленных оценок и количеству шагов рецепта, то есть сложный или простой рецепт, ну и в 4 классе, например медианное время готовки повыше. Успех в том, что по точкам видно, что пользователи близки друг к другу, к тому же и кластеры имеют явные отличия, которые могут характеризовать этот кластер.
# **Заключение**
Были проанализировал датасеты и выявлена стратегия кластеризации, добавлены нужные признаки, хорошо характеризующие наших пользователей, убрны мешающие редкие данные, которые портят вид графиков и проведён анализ того, что добавлено: выяснилось, что по итогу люди, у которых наиболее часто встречающаяся оценка 4 перемешались по разным кластерам, это роли не сыграло. И в конечном итоге цель исследования была достигнута и в конечном итоге разработана система, позволяющая в одну цепочку обработать данные и кластеризовать их на выходе получив список кластеров:



И ещё в конечном итоге можно получить такую визуализацию распределения кластеров:

А пользователи в кластерах удовлетворяют сформированные в цели требования.

# **Список использованной литературы и программ**
Документация по библиотеке scikit-learn — <https://scikit-learn.org/stable/modules/classes.html>

The 5 Clustering Algorithms Data Scientists Need to Know — <https://towardsdatascience.com/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68>

What is Clustering in Machine Learning: Types and Methods — <https://www.analytixlabs.co.in/blog/types-of-clustering-algorithms/>

1.Jupyter Notebook

\2. Python 3.10

\3. Plotly.express — Средство визуализации

4.Pandas — Средство работы с набором данных.

\5. Matplotlib — Средство визуализации

\6. Numpy — Библиотека для работы с данными.

\7. Seaborn. — Средство визуализации

\8. SQLAlchemy — средство для работы с базой данных

\9. Microsoft SQL Server Express edition — база данных, которая использовалась в исследовании

\10. Google Colab — web приложение для просмотра и редактирования файлов ipynb формата.




# **Приложения**
Код, позволяющий получить кластеры на основе имеющихся данных о пользователе <https://colab.research.google.com/drive/1XCbnC1PewFSX_WyB818dHHGDI4qVS0bV?usp=sharing>
